import groovy.xml.XmlParser
import net.ltgt.gradle.errorprone.CheckSeverity
import org.openstreetmap.josm.gradle.plugin.config.JosmManifest
import org.openstreetmap.josm.gradle.plugin.task.GeneratePluginList

import java.nio.file.Files
import java.nio.file.Paths
import java.util.stream.Collectors

plugins {
  id "com.diffplug.spotless" version "6.3.0"
  id "com.github.ben-manes.versions" version "0.42.0"
  id "com.github.spotbugs" version "5.0.6"
  // id "de.aaschmid.cpd" version "3.3"
  id "eclipse"
  id "jacoco"
  id "java"
  id "java-test-fixtures" /* Used for publishing test fixtures package */
  id "maven-publish"
  id "net.ltgt.errorprone" version "2.0.2"
  id "org.openstreetmap.josm" version "0.8.0"
  id "org.sonarqube" version "3.3"
  id "pmd"
}

int getJavaVersion() {
  // We want to use whatever Java version CI has as default
  def ci = project.hasProperty("isCI") or project.hasProperty("CI") or System.getenv("CI") != null
  // But we want to override if someone set a specific Java version
  def javaVersion = System.getenv("JAVA_VERSION")?.isInteger() ? Integer.valueOf(System.getenv("JAVA_VERSION")) : null
  if (javaVersion != null) {
    return javaVersion
  }
  if (ci) {
    return Integer.valueOf(JavaVersion.current().getMajorVersion())
  }
  return 8
}

logger.lifecycle("Using Java " + getJavaVersion())

java {
  toolchain {
    languageVersion.set(JavaLanguageVersion.of(getJavaVersion()))
  }
}

// Set up Errorprone
tasks.withType(JavaCompile).configureEach {
  options.errorprone {
    check("DefaultCharset", CheckSeverity.ERROR)
    check("StringEquality", CheckSeverity.ERROR)
    check("ConstantField",  CheckSeverity.WARN)
    check("FieldCanBeFinal", CheckSeverity.WARN)
    check("LambdaFunctionalInterface", CheckSeverity.WARN)
    check("MethodCanBeStatic", CheckSeverity.WARN)
    check("MultiVariableDeclaration", CheckSeverity.WARN)
    check("PrivateConstructorForUtilityClass", CheckSeverity.WARN)
    check("UngroupedOverloads", CheckSeverity.WARN)
    check("WildcardImport", CheckSeverity.WARN)
  }
}

rootProject.tasks.named("jar") {
    duplicatesStrategy = 'include'
}

archivesBaseName = "mapwithai"
def gitlabGroup = "gokaart"
def gitlabRepositoryName = "JOSM_MapWithAI"

repositories {
  mavenCentral()
  maven {
    url "https://josm.openstreetmap.de/nexus/content/repositories/releases/"
  }
}

sourceSets {
  test {
    java {
      srcDirs = ["src/test/unit"]
    }
    resources {
      srcDirs = ["src/test/resources"]
    }
  }
  testFixtures {
    java {
      srcDirs = ["src/test/unit"]
      setIncludes(new HashSet(['org/openstreetmap/josm/plugins/mapwithai/testutils/**/*.java']))
    }
    resources {
      srcDirs = ["src/test/resources"]
    }
  }
  intTest {
    compileClasspath += sourceSets.main.output
    compileClasspath += sourceSets.test.output
    runtimeClasspath += sourceSets.main.output
    runtimeClasspath += sourceSets.test.output
    java {
      srcDirs = ["src/test/integration"]
    }
    resources {
      srcDirs = ["src/test/resources"]
    }
  }
}

def versions = [
  awaitility: "4.1.1",
  // Errorprone 2.11 requires Java 11+
  errorprone: (JavaVersion.toVersion(getJavaVersion()) >= JavaVersion.VERSION_11) ? "2.11.0" : "2.10.0",
  jacoco: "0.8.7",
  jmockit: "1.49.a",
  junit: "5.8.2",
  pmd: "6.20.0",
  spotbugs: "4.5.3",
  wiremock: "2.32.0",
  findsecbugs: "1.11.0",
  josm: properties.get("plugin.compile.version"),
]

dependencies {
  if (!JavaVersion.toVersion(getJavaVersion()).isJava9Compatible()) {
    errorproneJavac("com.google.errorprone:javac:9+181-r4173-1")
  }
  spotbugsPlugins "com.h3xstream.findsecbugs:findsecbugs-plugin:${versions.findsecbugs}"
  errorprone("com.google.errorprone:error_prone_core:${versions.errorprone}")

  testFixturesImplementation("org.junit.jupiter:junit-jupiter-api:${versions.junit}")
  testFixturesRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:${versions.junit}")
  testFixturesImplementation("org.junit.vintage:junit-vintage-engine:${versions.junit}")
  testFixturesImplementation("org.junit.jupiter:junit-jupiter-params:${versions.junit}")
  testFixturesImplementation("org.jmockit:jmockit:${versions.jmockit}")
  testFixturesImplementation("com.github.spotbugs:spotbugs-annotations:${versions.spotbugs}")
  testFixturesImplementation("org.openstreetmap.josm:josm:${versions.josm}")
  testFixturesImplementation("org.openstreetmap.josm:josm-unittest:"){changing=true}
  testFixturesImplementation("com.github.tomakehurst:wiremock-jre8:${versions.wiremock}")
  testFixturesImplementation("org.awaitility:awaitility:${versions.awaitility}")
}

configurations {
    testImplementation.extendsFrom testFixturesImplementation
    testRuntimeOnly.extendsFrom testFixturesRuntimeOnly
    intTestRuntimeOnly.extendsFrom testRuntimeOnly
    intTestImplementation.extendsFrom testImplementation
}

// Add dependencies from ivy.xml
def ivyModule = new XmlParser().parse(new File("$projectDir/ivy.xml"))
logger.info("Dependencies from ivy.xml (added to configuration `packIntoJar`):")
ivyModule.dependencies.dependency.each {
  logger.info("  * ${it.@org}:${it.@name}:${it.@rev}")
  if (!"${it.@conf}".contains("test")) {
    project.dependencies.packIntoJar("${it.@org}:${it.@name}:${it.@rev}")
  }
}

test {
  project.afterEvaluate {
    jvmArgs("-javaagent:${classpath.find { it.name.contains("jmockit") }.absolutePath}")
    jvmArgs("-Djunit.jupiter.extensions.autodetection.enabled=true")
    jvmArgs("-Djava.awt.headless=true")
  }
  useJUnitPlatform()
  ignoreFailures
  testLogging {
    exceptionFormat "full"
    events "skipped", "failed"
    info {
      showStandardStreams true
    }
  }
}

task integrationTest(type: Test) {
  description = "Run integration tests"
  group = "verification"

  testClassesDirs = sourceSets.intTest.output.classesDirs
  classpath = sourceSets.intTest.runtimeClasspath
  shouldRunAfter test
  // Ignore failures -- servers may or may not be down
  ignoreFailures = true
}

check.dependsOn integrationTest

tasks.processResources {
  // Note: src/${source_set}/resources is automatically copied
  // processResources uses the `main` source set.
  // https://docs.gradle.org/current/userguide/building_java_projects.html#sec:java_resources
  from("$projectDir/LICENSE")
  from("$projectDir/README.md")
}

jacocoTestCoverageVerification {
  violationRules {
    rule {
      limit {
        minimum = 0.80
      }
    }
  }
}

spotless {
  java {
    eclipse().configFile "config/josm_formatting.xml"
    endWithNewline()
    importOrder('javax', 'java', 'org', 'com', '')
    indentWithSpaces(4)
    licenseHeader "// License: GPL. For details, see LICENSE file."
    ratchetFrom("origin/master")
    removeUnusedImports()
    trimTrailingWhitespace()
  }
}

josm {
  debugPort = 7055
  manifest {
    oldVersionDownloadLink 17903, "v1.8.7", new URL("https://gokaart.gitlab.io/JOSM_MapWithAI/dist/v1.8.7/mapwithai.jar")
    oldVersionDownloadLink 17084, "v1.7.1.6", new URL("https://gokaart.gitlab.io/JOSM_MapWithAI/dist/v1.7.1.6/mapwithai.jar")
    oldVersionDownloadLink 16645, "v1.6.8", new URL("https://gokaart.gitlab.io/JOSM_MapWithAI/dist/v1.6.8/mapwithai.jar")
    oldVersionDownloadLink 16284, "v1.5.10", new URL("https://gokaart.gitlab.io/JOSM_MapWithAI/dist/v1.5.10/mapwithai.jar")
    oldVersionDownloadLink 16220, "v1.4.7", new URL("https://gokaart.gitlab.io/JOSM_MapWithAI/dist/v1.4.7/mapwithai.jar")
    oldVersionDownloadLink 15820, "v1.3.11", new URL("https://gokaart.gitlab.io/JOSM_MapWithAI/dist/v1.3.11/mapwithai.jar")
    oldVersionDownloadLink 15737, "v1.2.7", new URL("https://gokaart.gitlab.io/JOSM_MapWithAI/dist/v1.2.7/mapwithai.jar")
    oldVersionDownloadLink 15609, "v1.1.12", new URL("https://gokaart.gitlab.io/JOSM_MapWithAI/dist/v1.1.12/mapwithai.jar")
    oldVersionDownloadLink 15542, "v1.0.9", new URL("https://gokaart.gitlab.io/JOSM_MapWithAI/dist/v1.0.9/mapwithai.jar")
    oldVersionDownloadLink 15233, "v0.2.14", new URL("https://gokaart.gitlab.io/JOSM_MapWithAI/dist/v0.2.14/mapwithai.jar")
  }
  i18n {
    pathTransformer = getPathTransformer(project.projectDir, "gitlab.com/${gitlabGroup}/${gitlabRepositoryName}/blob")
  }
}

tasks.withType(JavaCompile) {
  options.compilerArgs += [
    "-Xlint:all",
    "-Xlint:-serial",
  ]
}

// Set up JaCoCo
jacoco {
  toolVersion = "${versions.jacoco}"
}
jacocoTestReport {
  dependsOn test
  reports {
    xml.required.set(true)
    html.required.set(true)
  }
}
check.dependsOn jacocoTestReport

// Set up PMD
pmd {
  toolVersion = versions.pmd
  ignoreFailures true
  incrementalAnalysis = true
  ruleSets = []
  ruleSetConfig = resources.text.fromFile("$projectDir/config/pmd/ruleset.xml")
  sourceSets = [sourceSets.main]
}

// Set up SpotBugs
spotbugs {
  toolVersion = versions.spotbugs
  ignoreFailures = true
}
spotbugsMain {
  reports {
    xml.required.set(false)
    html.required.set(true)
  }
}

/**
 * Create a manifest map
 * @param manifest The manifest to convert
 * @return The map
 * @deprecated In v0.8.1 there will be a GenerateJarManifest class
 */
@Deprecated
Map<String, String> createUpdateManifest(JosmManifest manifest) {
  def returnMap = new TreeMap<String, String>();
  // Required fields first
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_MIN_JOSM_VERSION, manifest.minJosmVersion, false)
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_VERSION, project.version.toString(), false)
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_MAIN_CLASS, manifest.mainClass, false)
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_DESCRIPTION, manifest.description, false)
  putIfNotNull(returnMap, JosmManifest.Attribute.AUTHOR, manifest.author)
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_MIN_JAVA_VERSION, manifest.minJavaVersion)
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_PLATFORM, manifest.platform)
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_PROVIDES, manifest.provides)
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_EARLY, manifest.loadEarly)
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_ICON, manifest.iconPath)
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_DEPENDENCIES, manifest.pluginDependencies)
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_LOAD_PRIORITY, manifest.loadPriority)
  putIfNotNull(returnMap, JosmManifest.Attribute.PLUGIN_CAN_LOAD_AT_RUNTIME, manifest.canLoadAtRuntime)

  return returnMap
}

static putIfNotNull(Map<String, String> map, JosmManifest.Attribute attribute, Object value, boolean optional = true) {
  if (value instanceof Provider) {
    value = value.getOrNull()
  }
  if (value instanceof Collection) {
    value = (value as Collection).stream().map(Object::toString).collect(Collectors.joining(";"))
  }
  if (value != null && !value.toString().trim().isEmpty()) {
    map.put(attribute.manifestKey, value.toString());
  } else if (!optional) {
    throw new IllegalArgumentException("Attribute " + attribute.manifestKey + " cannot be null or empty");
  }
}

task generateSnapshotUpdateSite(type: GeneratePluginList) {
  dependsOn(tasks.processResources)

  outputFile = new File(project.buildDir, "snapshot-update-site")
  versionSuffix = {a -> ""}
  doFirst {
    def pluginDownloadUrl = "https://${gitlabGroup}.gitlab.io/${gitlabRepositoryName}/snapshot/master/${archivesBaseName}-dev.jar"
    it.iconBase64Provider = {
      def file = new File(sourceSets.main.resources.srcDirs[0], it)
      if (file.exists()) {
        def contentType = file.name.endsWith(".svg") ? "svg+xml" : "png"
        return "data:image/" + contentType + ";base64," + Base64.getEncoder().encodeToString(Files.readAllBytes(Paths.get(file.toURI())));
      }
    }
    /**
     * Generate a plugin jar manifest map
     * @deprecated GenerateJarManifest.kt was added after v0.8.0
     */
    def manifest = createUpdateManifest(project.josm.manifest as JosmManifest)
    it.addPlugin("$archivesBaseName-dev.jar", manifest, new URL(pluginDownloadUrl))
  }
}

publishing {
  publications {
    maven(MavenPublication) {
      groupId = "org.openstreetmap.josm.plugins"
      artifactId = archivesBaseName
      version = project.version

      from components.java
    }
  }
}

def ciJobToken = System.getenv("CI_JOB_TOKEN")
def projectId = System.getenv("CI_PROJECT_ID")
if (ciJobToken != null && projectId!= null) {
  publishing.repositories.maven {
    url = "https://gitlab.com/api/v4/projects/$projectId/packages/maven"
    name = "gitlab"
    credentials(HttpHeaderCredentials.class) {
      name = "Job-Token"
      value = ciJobToken
    }
    authentication {
      create("auth", HttpHeaderAuthentication.class)
    }
  }
}

sonarqube {
  properties {
    property "sonar.organization", "mapwithai"
    property "sonar.projectKey", "mapwithai"
    property "sonar.forceAuthentication", "true"
    property "sonar.host.url", "https://sonarcloud.io"
    property "sonar.projectDescription", properties.get("plugin.description")
    property "sonar.projectVersion", project.version
    property "sonar.sources", ["src"]
  }
}
